<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <meta name="viewport"
          content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <!-- Use the title from a page's frontmatter if it has one -->
    <title>The C Programming Language Books Notes</title>
    <link href="/stylesheets/site.css" rel="stylesheet" />
    <script src="/javascripts/site.js"></script>
  </head>
  <body>
    <html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>K&amp;R</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    pre > code.sourceCode { white-space: pre; position: relative; }
    pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
    pre > code.sourceCode > span:empty { height: 1.2em; }
    .sourceCode { overflow: visible; }
    code.sourceCode > span { color: inherit; text-decoration: inherit; }
    div.sourceCode { margin: 1em 0; }
    pre.sourceCode { margin: 0; }
    @media screen {
    div.sourceCode { overflow: auto; }
    }
    @media print {
    pre > code.sourceCode { white-space: pre-wrap; }
    pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
    }
    pre.numberSource code
      { counter-reset: source-line 0; }
    pre.numberSource code > span
      { position: relative; left: -4em; counter-increment: source-line; }
    pre.numberSource code > span > a:first-child::before
      { content: counter(source-line);
        position: relative; left: -1em; text-align: right; vertical-align: baseline;
        border: none; display: inline-block;
        -webkit-touch-callout: none; -webkit-user-select: none;
        -khtml-user-select: none; -moz-user-select: none;
        -ms-user-select: none; user-select: none;
        padding: 0 4px; width: 4em;
        color: #aaaaaa;
      }
    pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
    div.sourceCode
      {   }
    @media screen {
    pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
    }
    code span.al { color: #ff0000; font-weight: bold; } /* Alert */
    code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
    code span.at { color: #7d9029; } /* Attribute */
    code span.bn { color: #40a070; } /* BaseN */
    code span.bu { color: #008000; } /* BuiltIn */
    code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
    code span.ch { color: #4070a0; } /* Char */
    code span.cn { color: #880000; } /* Constant */
    code span.co { color: #60a0b0; font-style: italic; } /* Comment */
    code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
    code span.do { color: #ba2121; font-style: italic; } /* Documentation */
    code span.dt { color: #902000; } /* DataType */
    code span.dv { color: #40a070; } /* DecVal */
    code span.er { color: #ff0000; font-weight: bold; } /* Error */
    code span.ex { } /* Extension */
    code span.fl { color: #40a070; } /* Float */
    code span.fu { color: #06287e; } /* Function */
    code span.im { color: #008000; font-weight: bold; } /* Import */
    code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
    code span.kw { color: #007020; font-weight: bold; } /* Keyword */
    code span.op { color: #666666; } /* Operator */
    code span.ot { color: #007020; } /* Other */
    code span.pp { color: #bc7a00; } /* Preprocessor */
    code span.sc { color: #4070a0; } /* SpecialChar */
    code span.ss { color: #bb6688; } /* SpecialString */
    code span.st { color: #4070a0; } /* String */
    code span.va { color: #19177c; } /* Variable */
    code span.vs { color: #4070a0; } /* VerbatimString */
    code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">K&amp;R</h1>
</header>
<h2 id="the-c-programming-language-kernighan-ritchie-1978">The C
programming Language, Kernighan &amp; Ritchie (1978)</h2>
<ul>
<li>Basics:
<ul>
<li>variables and constants</li>
<li>arithmetic</li>
<li>control flow</li>
<li>functions</li>
<li>rudiments of input and output.</li>
</ul></li>
<li>Writing bigger programs:
<ul>
<li>pointers</li>
<li>structures</li>
<li>rich set of operators</li>
<li>several control-flow statements</li>
<li>and the standard library.</li>
</ul></li>
</ul>
<h5 id="introduction">Introduction</h5>
<blockquote>
<p>“A sequence of characters in double quotes, like
<code>hello, world\n</code>, is called a character string or string
constant”</p>
</blockquote>
<blockquote>
<p>“An escape sequence like <code>\n</code> provides a general and
extensible mechanism for representing hard-to-type or invisible
characters.”</p>
</blockquote>
<blockquote>
<p>“If an arithmetic operator has integer operands, an integer operation
is performed. If an arithmetic operator has one floating-point operand
and one integer operand, however, the interger will be converted to
floating point before the operation is done.”</p>
</blockquote>
<blockquote>
<p>“In any context where it is permissible to use the value of some
type, you can use a more complicated expression of that type.”</p>
</blockquote>
<blockquote>
<p>“A character written between single quotes represents an integer
value equal to the numerical value of the character in the machine’s
character set. This is called a character constant, although it is just
another way to write a small integer”</p>
</blockquote>
<h5 id="functions">Functions</h5>
<blockquote>
<p>“With properly designed functions, it is possible to ignore how a job
is done; knowing what is done is sufficient”</p>
</blockquote>
<h5 id="arguments---call-by-value">Arguments - Call by Value</h5>
<blockquote>
<p>“Call by value is an asset… It usually leads to more compact programs
with fewer extraneous variables, because parameters can be treated as
conveniently initialized local variables in the called routine.”</p>
</blockquote>
<h5 id="external-variables-and-scope">External Variables and Scope</h5>
<blockquote>
<p>“[…] discusses the static storage class, in which local variables do
retain their values between calls.”</p>
</blockquote>
<blockquote>
<p>“As an alternative to automatic variables, it is possible to define
variables that are external to all functions, that is, variables that
can be accessed by name by any function.”</p>
</blockquote>
<blockquote>
<p>“Before a function can use an external variables, the name of the
variable must be made known to the function; the declaration is the same
as before except for the added keyword extern.”</p>
</blockquote>
<blockquote>
<p>“In certain circumstances, the extern declaration can be omitted. If
the defintion of the external variable occurs in the source file before
its use in a particular function, then there is no need for an extern
declaration in the function. The extern declarations in main, getline,
and copy are thus redundant. In fact, commom practice is to place
definitions of all external variables at the beginning of the source
file, and then omit all extern declarations.”</p>
</blockquote>
<blockquote>
<p>“You should note that we are using the words definition and
declaration carefully when we refer to external variables in this
section. <code>Definition</code> refers to the place where the variables
is created or assigned storage; <code>declaration</code> refers to the
place where the nature of the variable is stated but not storage is
allocated”</p>
</blockquote>
<h4 id="types-operators-and-expressions">Types, Operators and
Expressions</h4>
<blockquote>
<p>“The type of an object determines the set of values it can have and
what operations can be performed on it.”</p>
</blockquote>
<blockquote>
<p>“Declarations list the variables to be used, and state what type they
haveand perhaps what their initial values are. Operators specify what is
to be done to them. Expressions combine variables and constants to
produce new values.”</p>
</blockquote>
<blockquote>
<p>“We tend to use short names for local variables, especially loop
indices, and longer names for external variables.”</p>
</blockquote>
<blockquote>
<p>“Be careful to distinguish between a character constant and a string
that contains a single character: ‘x’ is not the same as”x”. The former
is an integer, used to produce the numeric value of the letter x in the
machine’s character set. The latter is an array of characters that
contains one character (the letter x) and a ‘\0’.”</p>
</blockquote>
<blockquote>
<p>“There is one other kind of constant, the enumeration constant. An
enumeration is a list of constant values, as in:</p>
</blockquote>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> boolean <span class="op">{</span> NO<span class="op">,</span> YES <span class="op">};</span></span></code></pre></div>
<p>The first name in an enum has value 0, the next 1, and so on, unless
explicit values are specified.”</p>
<p>If not all values are specified, unspecified values continue the
progression form the last specified value:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">enum</span> months <span class="op">{</span> JAN <span class="op">=</span> <span class="dv">1</span><span class="op">,</span> FEB<span class="op">,</span> MAR<span class="op">,</span> APR<span class="op">,</span> MAY<span class="op">,</span> JUN<span class="op">,</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>              JUL<span class="op">,</span> AUG<span class="op">,</span> SEP<span class="op">,</span> OCT<span class="op">,</span> NOV<span class="op">,</span> DEC <span class="op">};</span></span></code></pre></div>
<blockquote>
<p>“The quatifier const can be applied to the declaration of any
variable to specify that its value will not be changed. For an array,
the const qualifier says that the elements will not be altered.”</p>
</blockquote>
<blockquote>
<p>“The const declaration can also be used with array arguments, to
indicate that the function does not change that array:
<code>int strlen(const char[]);</code>”</p>
</blockquote>
<blockquote>
<p>“The expression <code>x % y</code> produces the remainder when x is
devided by y, and thus is zero when y divides x exactly. For example, a
year is a leap year if it is divisible by 4 but not by 100, except that
years divisible by 400 are leap years.”</p>
</blockquote>
<div class="sourceCode" id="cb3"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">((</span>year <span class="op">%</span> <span class="dv">4</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> year <span class="op">%</span> <span class="dv">100</span> <span class="op">!=</span> <span class="dv">0</span><span class="op">)</span> <span class="op">||</span> year <span class="op">%</span> <span class="dv">400</span> <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d is a leap year</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> year<span class="op">);</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d is not a leap year</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> year<span class="op">);</span></span></code></pre></div>
<blockquote>
<p>“The precedence of &amp;&amp; is higher than that of ||, and both are
lower than relational and equality operators”</p>
</blockquote>
<blockquote>
<p>“By definition, the numeric value of a relational or logical
expression is 1 if the relation is true, and 0 if the relation is
false.”</p>
</blockquote>
<blockquote>
<p>The unary negation operator ! converts a non-zero operand into 0, and
a zero operand in 1. A common use of ! is in constructions like:</p>
</blockquote>
<div class="sourceCode" id="cb4"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(!</span>valid<span class="op">)</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* rather than */</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="op">(</span>valid <span class="op">==</span> <span class="dv">0</span><span class="op">)</span></span></code></pre></div>
<h5 id="type-conversion">Type conversion</h5>
<blockquote>
<p>In general, if an operator like + or * that takes two operands has
operands of different types, the “lower” type is promoted to the
“highter” type before the operation proceeds.</p>
</blockquote>
<blockquote>
<p>Conversions take place across assignments; the value of the right
side is converted to the type of the left, which is the type of the
result.</p>
</blockquote>
<blockquote>
<p>Since an argument of a function call is an expression, type
conversion also takes place when arguments are passed to functions. In
the absence of a function prototype, char and short become int and float
becomes double.</p>
</blockquote>
<blockquote>
<p>Finally, explicit type conversions can be forced (‘coerced’) in any
expression, with a unary operator called a cast. […] The precise meaning
of a cast is as if the expression were assigned to a variable of the
specified type, which is then used in place of the whole
construction.</p>
</blockquote>
<p>The &lt;math.h&gt; library routine sqrt expects a double argument,
and will produce nonsense if inadvertently handled something else. So if
“n” is an interger, we can use:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a>sqrt<span class="op">((</span><span class="dt">double</span><span class="op">)</span> n<span class="op">)</span></span></code></pre></div>
<p>to convert the value of n to double before passing it to sqrt.</p>
<h4 id="increment-and-decrement-operators">Increment and Decrement
Operators</h4>
<p>In a context where no value is wanted, just the incrementing effect,
prefix and postfix are the same.</p>
<p>But there are situations where one or the other is specifically
called for:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* squeeze: delete all c from s */</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> squeeze<span class="op">(</span><span class="dt">char</span> s<span class="op">[],</span> <span class="dt">int</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> j <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> s<span class="op">[</span>i<span class="op">]</span> <span class="op">!=</span> <span class="ch">&#39;\0&#39;</span><span class="op">;</span> i<span class="op">++)</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">!=</span> c<span class="op">)</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>            s<span class="op">[</span>j<span class="op">++]</span> <span class="op">=</span> s<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    s<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> <span class="ch">&#39;\0&#39;</span><span class="op">;</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">/* this is exactly equivalent to */</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>s<span class="op">[</span>i<span class="op">]</span> <span class="op">!=</span> c<span class="op">)</span> <span class="op">{</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>        s<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> s<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        j<span class="op">++;</span></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<h5 id="bitwise-operators">Bitwise Operators</h5>
<div class="sourceCode" id="cb7"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* getbits: get n bits from position p */</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="dt">unsigned</span> getbits<span class="op">(</span><span class="dt">unsigned</span> x<span class="op">,</span> <span class="dt">int</span> p<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>x <span class="op">&gt;&gt;</span> <span class="op">(</span>p<span class="op">+</span><span class="dv">1</span><span class="op">-</span>n<span class="op">))</span> <span class="op">&amp;</span> <span class="op">~(~</span><span class="dv">0</span> <span class="op">&lt;&lt;</span> n<span class="op">);</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>This bitwise section is all about understanding this return
statement.</p>
<p>First getbits, extracts <code>n</code> bits starting from position
<code>p</code> in the integer <code>x</code>, these extracted bits are
then “right adjusted”, meaning that they are shifted to the right end of
the integer (the rest of the bits to the left are set to zero).</p>
<p>Example:</p>
<p><code>x = 10110100</code> and you want to extract 3 bits starting
from position 4, you would extract <code>101</code>. Then adjusting,
would end up with <code>00000101</code></p>
<p><code>x &gt;&gt; (p+1-n)</code>: this shifts the desired part at the
right end.</p>
<p><code>~0</code>: this is a common idiom to inverts every bit.</p>
<p><code>~0 &lt;&lt; n</code>: This shifts all-1s value <code>n</code>
positions to the left, which sets the <code>n</code> rightmost bits to 0
and the rest to 1.</p>
<p><code>~(~0 &lt;&lt; n)</code>: This inverts the bits, producing a
mask, where only the <code>n</code> rightmost bits are set to 1, and the
rest to 0.</p>
<p><code>&amp;</code>: apply the mask produced above, leaving only the
<code>n</code>righmost its of the shifted <code>x</code></p>
<hr />
<h3 id="x-x---1">x &amp;= x - 1</h3>
<p>The expression <code>x &amp;= x - 1</code> is a clever and efficient
way to count the number of 1 bits (set bits) in an integer.</p>
<p>Let consider what happens when you subtract 1 from a binary
number:</p>
<p><code>x - 1</code> - If LSB is 1 <code>001</code>, subtrating 1 will
turn it to 0 <code>000</code> - If LSB is 0, the subtraction borrows
from a more significant bit, flippingall trailing 0s to 1s until it
reaches a 1, which is flipped to 0.</p>
<p><code>x &amp;=</code></p>
<p>Performs a bitwise AND on x with the result of <code>x - 1</code>.
This operation clears the least significant set bit.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> <span class="dv">12</span><span class="op">;</span> <span class="co">/* 1100 */</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co">/* x - 1 = 11;  1011 */</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">&amp;=</span> x <span class="op">-</span> <span class="dv">1</span><span class="op">;</span> <span class="co">/* 1100 &amp; 1011 = 1000 (8 in decimal) */</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="co">/* x - 1 = 7;  0111 */</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>x <span class="op">&amp;=</span> x <span class="op">-</span> <span class="dv">1</span> <span class="co">/* 1000 &amp; 0111 = 0000 */</span></span></code></pre></div>
<h3 id="control-flow">Control Flow</h3>
<blockquote>
<p>“… it’s a good idea to use braces when there are nested ‘ifs’”</p>
</blockquote>
<blockquote>
<p>“… the last ‘else’ part handles the ‘none of the above’ or default
case where none of the other conditions is satisfied.”</p>
</blockquote>
<h4 id="switch">Switch</h4>
<blockquote>
<p>“The break statement causes an immediate exit from the switch.
Because cases serve just as labels, after the code for one case is done,
execution falls through to the next unless you take explicit action to
escape. break and return are the most common ways to leave a
switch.”</p>
</blockquote>
<h4 id="loops">Loops</h4>
<blockquote>
<p>“One final C operator is the comma”,“, which most often finds use in
the for statement. A pair of expressions separated by a comma is
evaluated left to right, and the type and value of the result are the
type and value of the right operand.”</p>
</blockquote>
<div class="sourceCode" id="cb9"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> reverse<span class="op">(</span><span class="dt">char</span> s<span class="op">[])</span> <span class="op">{</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> c<span class="op">,</span> i<span class="op">,</span> j<span class="op">;</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> j <span class="op">=</span> strlen<span class="op">(</span>s<span class="op">)-</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> j<span class="op">;</span> i<span class="op">++,</span> j<span class="op">--)</span> <span class="op">{</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>        c <span class="op">=</span> s<span class="op">[</span>i<span class="op">];</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>        s<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> s<span class="op">[</span>j<span class="op">];</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>        s<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> c<span class="op">;</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> <span class="op">(</span>i <span class="op">=</span> <span class="dv">0</span><span class="op">,</span> j <span class="op">=</span> strlen<span class="op">(</span>s<span class="op">)-</span><span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> j<span class="op">;</span> i<span class="op">++,</span> j<span class="op">--)</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    c <span class="op">=</span> s<span class="op">[</span>i<span class="op">],</span> s<span class="op">[</span>i<span class="op">]</span> <span class="op">=</span> s<span class="op">[</span>j<span class="op">],</span> s<span class="op">[</span>j<span class="op">]</span> <span class="op">=</span> c<span class="op">;</span></span></code></pre></div>
<h4 id="break-continue">Break &amp; Continue</h4>
<p>It is sometimes convenient to be able to exit from a loop other than
by testing at the top or bottom (for/while loop or do/while loop). The
break statement provides an early exit from for, while, and do. A break
causes the innermost enclosing loop or switch to be exited
immediately.</p>
<p>The continue statement is related to break, but less often used; it
causes the next iterations of the enclosing for, while, or do loop to
begin. In the while and do, this means that the test part is executed
immediately; in the for, control passes to the increment step.</p>
<h4 id="goto-and-labels">Goto and labels</h4>
<blockquote>
<p>“The are a few situations where goto(s) may find a place. The most
common is to abandon processing in some deeply nested structure, such as
breaking out of two or more loops at once. The break statement cannot be
used directly since it only exits from the innermost loop.”</p>
</blockquote>
<h4 id="function">Function</h4>
<blockquote>
<p>“C has been designed to make functions efficient and easy to use; C
programs generally consist of many small functions rather than a few big
ones”</p>
</blockquote>
<blockquote>
<p>“Coercion: in the context of function type declarations refers to the
automatic conversion of a value from one type to another.”</p>
</blockquote>
<blockquote>
<p>“[…] Because C arrays begin at position zero, indexes will be zero or
positive, and so a negative value like -1 is convenient for signaling
failure.”</p>
</blockquote>
<blockquote>
<p>“A program is just a set of definition of variables and functions.
Communication between the functions is by arguments and values returned
by the functions, and through external variables.”</p>
</blockquote>
<h4 id="external-variables"> External Variables</h4>
<blockquote>
<p>“A C program consists of a set of external objects, which are either
variables or functions. The adjective ‘external’ is used in contrast to
‘internal’, which describes the arguments and variables defined inside
functions.”</p>
</blockquote>
<blockquote>
<p>“We will see later how to define external variables and functions
that are visible only within a single source file. Because external
variables are globally accessible, they provide an alternative to
function arguments and return values for communicationg data between
functions. Any function may access an external variable by referring to
it by name, if the name has been declared somehow.”</p>
</blockquote>
<blockquote>
<p>“External variables are also useful because of their greater scope
and lifetime. Automatic variables are internal to a function; they come
into existence when then function is entered, and disappear when it is
left. External variables, on the other hand, are permanent, so they can
retain values from one function invocation to the next. Thus if two
functions must share some data, yet neither calls the other, it is often
most convenient if the shared data is kept in external variables rather
than being passed in and out via arguments.”</p>
</blockquote>
<h4 id="scope-rules">Scope Rules</h4>
<p>It is important to distinguish between the declaration of an external
variable and its definiton. A declaration announces the properties of a
variable (primarly its type); a definiton also causes storage to be set
aside.</p>
<p>If lines:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sp<span class="op">;</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> val<span class="op">[</span>MAXVAL<span class="op">];</span></span></code></pre></div>
<p>appear outside of any function, they define the external variables sp
and val, cause storage to be set aside, and also serve as the
declarations for the rest of that source file. On the other hand, the
lines</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">extern</span> <span class="dt">int</span> sp<span class="op">;</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">extern</span> <span class="dt">double</span> val<span class="op">[];</span></span></code></pre></div>
<p>declare for the rest of the source file that sp is an int and that
val is a double array (whose size is determined elsewhere), but they do
not create the variables or reserve storage for them.</p>
<p>There must be only one definition of an external variable among all
the files that make up the source program; other files may contain
extern declarations to acces it.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* in file1: */</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">extern</span> <span class="dt">int</span> sp<span class="op">;</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">extern</span> <span class="dt">double</span> val<span class="op">[];</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> push<span class="op">(</span><span class="dt">double</span> f<span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> pop<span class="op">(</span><span class="dt">void</span><span class="op">)</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span></span></code></pre></div>
<div class="sourceCode" id="cb14"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* in file2: */</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sp <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> val<span class="op">[</span>MAXVAL<span class="op">];</span></span></code></pre></div>
<p>source: page 73.</p>
<h4 id="static-variables">Static Variables</h4>
<blockquote>
<p>“static storage class should be used only when a program requires the
value of a varaible to persist between different function calls, like in
recursive calls” Exploring C - YPK</p>
</blockquote>
<p>The static declaration, applied to an external variable or function,
limits the scope of that object to the rest of the source file being
compiled. External static thus provides a way to hide names like
<code>buf</code> and <code>bufp</code> in the getch-ungetch combination,
which must be external so they can be shared, yet which should not be
visible to users(place where function is call) of getch and ungetch.</p>
<p>source: page 75.</p>
<h4 id="initialization">Initialization</h4>
<p>In the absence of explicit initialization, external and static
variables are guaranteed to be initialized to zero; automatic and
register variables have undefined (i.e, garbage) initial values.</p>
<p>For external and static variables, the initializer must be a constant
expression;</p>
<p>For automatic and register variables, the initializer is not
restricted to being a constant: it may be any expression involving
previously defined values, even function calls.</p>
<p>In effect, initialization of automatic variables are just shorthand
for assignement statements. Which form to prefer is largely a matter of
taste. We have generally used explicit assignments, because initializes
in declarations are harder to see and further away from the point of
use.</p>
<p>An array may be initialized by following its declaration with a list
of initializers enclosed in braces and separated by commas.</p>
<p>Character arrays are a special case of initialization; a string may
be used instead of the braces and commans notation:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> pattern <span class="op">=</span> <span class="st">&quot;ould&quot;</span><span class="op">;</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* is a shorthand for the longest but equivalent */</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> pattern <span class="op">=</span> <span class="op">{</span> <span class="ch">&#39;o&#39;</span><span class="op">,</span> <span class="ch">&#39;u&#39;</span><span class="op">,</span> <span class="ch">&#39;l&#39;</span><span class="op">,</span> <span class="ch">&#39;d&#39;</span><span class="op">,</span> <span class="ch">&#39;\0&#39;</span> <span class="op">};</span></span></code></pre></div>
<h4 id="recursion">Recursion</h4>
<p>C functions may be used recursively; that is, a function may call
itself either directly or indirectly.</p>
<p>When a function calls itself recursively, each invocation gets a
fresh set of all the automatic variables, independent of the previous
set.</p>
<h4 id="the-c-preprocessor">The C Preprocessor</h4>
<p>C provides certain language facilities by means of a preprocessor,
which is conceptionally a separate first step in compilation.</p>
<h4 id="macro-substitution">Macro Substitution</h4>
<div class="sourceCode" id="cb16"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define name replacement text</span></span></code></pre></div>
<p>It calls for a macro substitution of the simplest kind - subsequent
occurences of the token name will be replaced by the replacement
text.</p>
<p>The scope of a name defined with #define is from its point of
definition to the end of the source file being compiled.</p>
<p>It is also possible to define macros with arguments, so the
replacement text can be different for different calls of the macro.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define max(A, B) ((A) &gt; (B) ? (A) : (B))</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> max<span class="op">(</span>p<span class="op">+</span>q<span class="op">,</span> r<span class="op">+</span>s<span class="op">);</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* will be replaced by the line */</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>    x <span class="op">=</span> <span class="op">((</span>p<span class="op">+</span>q<span class="op">)</span> <span class="op">&gt;</span> <span class="op">(</span>r<span class="op">+</span>s<span class="op">)</span> <span class="op">?</span> <span class="op">(</span>p<span class="op">+</span>q<span class="op">)</span> <span class="op">:</span> <span class="op">(</span>r<span class="op">+</span>s<span class="op">))</span></span></code></pre></div>
<p>Note, macros are essentially textual replacements, ensure proper
precedence by adding parentheses to the macro definiton</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define square(x) x * x</span></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    square<span class="op">(</span>z<span class="op">+</span><span class="dv">1</span><span class="op">)</span> <span class="co">/* =&gt; z + 1 * z + 1, wrong precedence */</span></span></code></pre></div>
<h4 id="pointers">Pointers</h4>
<p>The <code>void *</code> pointer is the proper type for a generic
pointer.</p>
<p>As a pointer, <code>void *</code> can point to any data type, but you
cannot directly dereference a <code>void *</code> without first casting
it to another pointer type that points to a specific data type.</p>
<p>Before the adoption of <code>void *</code> as a generic pointer,
<code>char *</code> was frequently used for this purpose. This is
because a <code>char</code> in C is defined to be 1 byte, and
<code>char *</code> can access each byte of memory individually.</p>
<p>Using <code>void *</code> pointer is like positioning a cursor at a
starting point in memory. At this stage, the pointer simply indicates
where something is located but doesn’t provide information about what
exactly is at that location or how it should be interpreted.</p>
<p>The unary operator <code>&amp;</code> gives the address of an object.
This operator only applies to objects in memory: variables and array
elements.</p>
<p>The unary operator <code>*</code> is the indirection or dereferencing
operator; when applied to a pointer, it accesses the object the pointer
points to.</p>
<h5 id="pointers-and-function-arguments">Pointers and Function
arguments</h5>
<p>Since C passes argument to functions by value, there is no direct way
for the called function to alter a variable on the calling function. The
way to obtain the desired effect is for the calling program to pass
pointers to the values to be changed.</p>
<h5 id="pointers-and-arrays">Pointers and Arrays</h5>
<p>Any operations that can be achieved by array subscripting can also be
done with pointers.</p>
<p>The correspondence between indexing and pointer arithmetic is very
close. By definiton, the value of a variable or expression of type array
is the address of element zero of the array. Since the name of an array
is a synonym for the location of the initial element, the assignment
<code>pa=&amp;a[0]</code> can also be written as
<code>pa = a</code>;</p>
<p>Rather more surprising, at first sight, is the fact that a reference
to a[i] can also be written as <em>(a+1). In evaluating a[i], C converts
it to </em>(a+i) immediately; the two forms are equivalent.</p>
<p>In C, <code>[ ]</code> is metaphorically equivalent to
<code>* +</code> becoming <code>* (array_name + subscript)</code></p>
<p>In short, an array-and-index expression is equivalent to one written
as a pointer and offset.</p>
<p>An array name has a special behavior that distinguishes it from
regular variables. Instead, it acts as a constant pointer to the first
element of the array. The key distinction is that while ‘a’ behaves like
a pointer, you cannot change its value. That is, ‘a’ is a constant
pointer, ‘a’ is not a modifiable value.</p>
<p>The array name ‘a’ gives the address of the first element, but itself
is not stored anywhere as a separate entity. It’s more of a compile-time
constructthat refers to the memory location where the array elements are
stored.</p>
<p>When an array name is passed to a function, what is passed is the
location of the initial element. Within the called function, this
argument is a local variable, and so an array name parameter is a
pointer, that is, a variable containing an address.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* as formal parameters in a function definition, */</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> s<span class="op">[];</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* and */</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>s<span class="op">;</span></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* are equivalent; we prefer the latter because it says more</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co">     * explicitly that the variable is a pointer */</span></span></code></pre></div>
<h4 id="address-arithmetic">Address Arithmetic</h4>
<div class="sourceCode" id="cb20"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* strlen: return length of string s */</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> strlen<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>s<span class="op">)</span> <span class="op">{</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> <span class="op">*</span>p <span class="op">=</span> s<span class="op">;</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">while</span> <span class="op">(*</span>p <span class="op">!=</span> <span class="ch">&#39;\0&#39;</span><span class="op">)</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>            p<span class="op">++;</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> p <span class="op">-</span> s<span class="op">;</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>In the while loop the pointer increment until is own address is equal
to <code>\0</code></p>
<h4 id="character-pointers-functions">Character Pointers &amp;
Functions</h4>
<p>A string constant is accessed by a pointer to its first element.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>pmessage<span class="op">;</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co">/* assigns to pmessage a pointer to the character array */</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>pmessage <span class="op">=</span> <span class="st">&quot;now is the time&quot;</span><span class="op">;</span></span></code></pre></div>
<p>There is an important difference between these defintions:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> amessage<span class="op">[]</span> <span class="op">=</span> <span class="st">&quot;now is the time&quot;</span><span class="op">;</span> <span class="co">/* an array */</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>pmessage <span class="op">=</span> <span class="st">&quot;now is the time&quot;</span><span class="op">;</span>  <span class="co">/* a pointer */</span></span></code></pre></div>
<p>Arrays have their own storage, while pointers reference existing
storage, typically read-only in the case of string literals. Arrays and
pointers are fundamentally different in C, although they can be accessed
similarly in many contexts. The main differences are the memory
allocation and size. The similarities are, accessing elements (both can
be used to access elements using the subscript operator <code>[]</code>,
notation, and (pointer)arithmetic.</p>
<p>In C, an assignement operations returns the value that was
assigned.</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* strcpy: copy t to s; pointer version 2 */</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> strcpy<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>s<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">((*</span>s<span class="op">++</span> <span class="op">=</span> <span class="op">*</span>t<span class="op">++)</span> <span class="op">!=</span> <span class="ch">&#39;\0&#39;</span><span class="op">)</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        <span class="op">;</span></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>Interesting idiom, frequently used in C:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* the comparison against &#39;\0&#39; is redundant, since the question</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="co">* is merely whether the expresion is zero */</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="co">/* strcpy: copy t to s: pointer version 3 */</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="dt">void</span> strcpy<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>s<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>t<span class="op">)</span> <span class="op">{</span></span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">while</span> <span class="op">(*</span>s<span class="op">++</span> <span class="op">=</span> <span class="op">*</span>t<span class="op">++)</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>        <span class="op">;</span></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a><span class="co">/* &#39;\0&#39; has an integer value of 0 */</span></span></code></pre></div>
<p>Standard idiom for pushing and popping a stack:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>    <span class="op">*</span>p<span class="op">++</span> <span class="op">=</span> val<span class="op">;</span>     <span class="co">/* push val onto stack */</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>    val <span class="op">=</span> <span class="op">*--</span>p<span class="op">;</span>    <span class="co">/* pop top of stack into val */</span>   </span></code></pre></div>
<p>NOTE:</p>
<p>It’s great practice to <code>return 0</code> indicating equality.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> strncmp<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>s<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>t<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> <span class="op">(</span> <span class="op">;</span> <span class="op">*</span>s <span class="op">==</span> <span class="op">*</span>t<span class="op">;</span> s<span class="op">++,</span> t<span class="op">++)</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(*</span>s <span class="op">==</span> <span class="ch">&#39;\0&#39;</span> <span class="op">||</span> <span class="op">--</span>n <span class="op">&lt;=</span> <span class="dv">0</span><span class="op">)</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">*</span>s <span class="op">-</span> <span class="op">*</span>t<span class="op">;</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>In this case, if either condition is met,
(<code>*s == '\0' || --n &lt;= 0</code>), the function return 0,
indicating that the strings are equal. Else we return the difference
(<code>*s - *t</code>) indicating whether the character from ‘s’ is
greater than or less than.</p>
<h5 id="pointer-arrays-pointers-to-pointers">Pointer Arrays; Pointers to
pointers</h5>
<div class="sourceCode" id="cb27"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>lineptr<span class="op">[</span>MAXLINES<span class="op">]</span></span></code></pre></div>
<p>This line says that lineptr is an array of MAXLINES elements, each
element of which is a pointer to a char.</p>
<h4 id="initialization-of-pointer-arrays">Initialization of Pointer
Arrays</h4>
<p>Ideal application for an internal <code>static</code> array.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a><span class="co">/* month_name: return name of n-th month */</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a><span class="dt">char</span> <span class="op">*</span>month_name<span class="op">(</span><span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">static</span> <span class="dt">char</span> <span class="op">*</span>name<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;Illegal month&quot;</span><span class="op">,</span></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;January&quot;</span><span class="op">,</span> <span class="st">&quot;February&quot;</span><span class="op">,</span> <span class="st">&quot;March&quot;</span><span class="op">,</span></span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;April&quot;</span><span class="op">,</span> <span class="st">&quot;May&quot;</span><span class="op">,</span> <span class="st">&quot;June&quot;</span><span class="op">,</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;July&quot;</span><span class="op">,</span> <span class="st">&quot;August&quot;</span><span class="op">,</span> <span class="st">&quot;September&quot;</span><span class="op">,</span></span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;October&quot;</span><span class="op">,</span> <span class="st">&quot;November&quot;</span><span class="op">,</span> <span class="st">&quot;December&quot;</span></span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-11"><a href="#cb28-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="op">(</span>n <span class="op">&lt;</span> <span class="dv">1</span> <span class="op">||</span> n <span class="op">&gt;</span> <span class="dv">12</span><span class="op">)</span> <span class="op">?</span> name<span class="op">[</span><span class="dv">0</span><span class="op">]</span> <span class="op">:</span> name<span class="op">[</span>n<span class="op">];</span></span>
<span id="cb28-12"><a href="#cb28-12" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>The <code>static</code> keyword ensures that the array
<code>name</code> retains its value across multiple calls of the same
function. This means that the array is only initialized once.</p>
<h4 id="command-line-arguments">Command-line Arguments</h4>
<blockquote>
<p>“In environments that support C, there is a way to pass command-line
arguments or parameters to a program when it begins executing. When main
is called, it is called with two arguments. The first (conventionally
called argc, for argument count) is the number of command-line arguments
the program was invoked with; the second (argv, for argument vector) is
a pointer to an array of character strings that contain the arguments,
one pers string.”</p>
</blockquote>
<blockquote>
<p>“A common convention for C programs on UNIX systems is that an
arguments that begins with a minus sign introduces an optional flag or
parameter. If we choose -x (for except) to signal the inversion, and -n
(number) to request line numbering, then the command
<code>find -x -n pattern</code> will print each line that doesn’t match
the pattern, preceded by its line number”</p>
</blockquote>
<p>How the -x flag work. Here the table of truth: (code page 105)</p>
<table>
<colgroup>
<col style="width: 43%" />
<col style="width: 14%" />
<col style="width: 18%" />
<col style="width: 23%" />
</colgroup>
<thead>
<tr class="header">
<th><code>strstr(line, *argv) != NULL</code></th>
<th><code>except</code></th>
<th><code>!= except</code></th>
<th>Result</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1 (substring found)</td>
<td>0</td>
<td>1 != 0</td>
<td>1 (print line)</td>
</tr>
<tr class="even">
<td>0 (substring not found)</td>
<td>0</td>
<td>0 != 0</td>
<td>0 (skip line)</td>
</tr>
<tr class="odd">
<td>1 (substring found)</td>
<td>1</td>
<td>1 != 1</td>
<td>0 (skip line)</td>
</tr>
<tr class="even">
<td>0 (substring not found)</td>
<td>1</td>
<td>0 != 1</td>
<td>1 (print line)</td>
</tr>
</tbody>
</table>
<h3 id="pointers-to-functions">Pointers to Functions</h3>
<blockquote>
<p>“A sort often consists of three parts - a comparison that determines
the ordering of any pair of objects, an exchange that reverses their
order, and a sorting algorithm that makes comparisons and exchanges
until the objects are in order.”</p>
</blockquote>
<blockquote>
<p>“Any pointer can be cast to void * and back again without loss of
information, so we can call qsort by casting arguments to void *.”</p>
</blockquote>
<p><code>int (*comp)(void *, void *)</code> says that comp is a pointer
to a function that has two void * arguments and returns an int.</p>
<p>whereas <code>int *comp(void *, void *) /* wrong */</code> says that
comp is a function returning a pointer to an int, which is very
different.</p>
<h3 id="complicated-declarations">Complicated Declarations</h3>
<div class="sourceCode" id="cb29"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>f<span class="op">();</span>   <span class="co">/* f: function returning pointer to int */</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">(*</span>pf<span class="op">)();</span>    <span class="co">/* pf: pointer to function returning int */</span></span></code></pre></div>
<p>‘dcl’ -&gt; declaration</p>
<blockquote>
<p>“It’s good to know that ‘declaration’ can be quite an art to
understand, with all their subtleties.”</p>
</blockquote>
<div class="sourceCode" id="cb30"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">**</span>argv<span class="op">;</span>    <span class="co">/* equivalent of char *argv[];  */</span></span></code></pre></div>
<div class="sourceCode" id="cb31"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> array1<span class="op">[</span><span class="dv">13</span><span class="op">];</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> array2<span class="op">[</span><span class="dv">13</span><span class="op">];</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">(*</span>daytab<span class="op">)[</span><span class="dv">13</span><span class="op">];</span>  <span class="co">/* daytab is a pointer to array of 13 integers */</span></span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>    daytab <span class="op">=</span> <span class="op">&amp;</span>array1<span class="op">;</span></span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>    daytab <span class="op">=</span> <span class="op">&amp;</span>array2<span class="op">;</span></span></code></pre></div>
<div class="sourceCode" id="cb32"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> <span class="op">*</span>daytab<span class="op">[</span><span class="dv">13</span><span class="op">];</span>    <span class="co">/* daytab: array[13] of pointer to int */</span></span></code></pre></div>
<div class="sourceCode" id="cb33"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">*</span>comp<span class="op">()</span> <span class="op">{}</span> <span class="co">/* comp: function returning pointer to void */</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> <span class="op">(*</span>comp<span class="op">)()</span> <span class="op">{}</span>   <span class="co">/* comp: pointer to function returning void */</span></span></code></pre></div>
<div class="sourceCode" id="cb34"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">(*(*</span>x<span class="op">())[])();</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* x: function returning pointer to array[] of pointer to function returning char */</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">(*(*</span>x<span class="op">[</span><span class="dv">3</span><span class="op">])())[</span><span class="dv">5</span><span class="op">];</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* x: array[3] of pointer to function returning pointer to array[5] of char */</span></span></code></pre></div>
<p><code>char (*(*x())[])()</code> “x is a function returning a pointer
to an array of pointers to functions returning char”</p>
<h2 id="structures">Structures</h2>
<blockquote>
<p>“A structure is a collection of one or more variables, possibly of
different types, grouped together under a single name for convenient
handling. Structures help to organize complicated data, particulary in
large programs, because they permit a group of related variables to be
treated as a unit instead of as separate entities.”</p>
</blockquote>
<div class="sourceCode" id="cb35"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* Basics of Structures </span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a><span class="co">     * Let us create a basic point object</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co">     * Two components can be placed in a structure declared like this:</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> point <span class="op">{</span></span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> x<span class="op">;</span></span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> y<span class="op">;</span></span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<p>The keyword <code>struct</code> introduces a structure declaration,
which is a list of declarations enclosed in braces. An optional name
called a <strong>structure tag</strong> may follow the word
<code>struct</code>. The tag names this king of structure, and can be
used subsequently as a shorthand for the part of the declaration in
braces. The variables named in a structure are called members.</p>
<p>A <code>struct</code> declarations defines a type. The right brace
that terminates the list of members may be followed by a list of
variables, just as for any basic type. That is,</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> <span class="op">{</span> <span class="op">...</span> <span class="op">}</span> x<span class="op">,</span> y<span class="op">,</span> z<span class="op">;</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* is syntactically analogous to */</span></span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> x<span class="op">,</span> y<span class="op">,</span> z<span class="op">;</span></span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* in the sense that each statement declares x, y and z to be</span></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true" tabindex="-1"></a><span class="co">     * variables of the named type and causes space to be set aside for them</span></span>
<span id="cb36-6"><a href="#cb36-6" aria-hidden="true" tabindex="-1"></a><span class="co">     */</span></span></code></pre></div>
<p>A structure declaration that is not followed by a list of variables
reserves no storage; it merely describes a template or shape of a
structure. If the declaration is tagged, however, the tag can be used
later in definitions of instances of the structure.</p>
<p>For example, <code>struct point pt;</code> defines a variable pt
which is a structure of type <code>struct point</code></p>
<p>A structure can be initialized by following its definition with a
list of initializers, each a constant expression, for the members:
<code>struct maxpt = { 320, 200 };</code></p>
<p>The structure member operator <code>.</code> connects the structure
name and the member name. To print the coordinates of the point pt:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>    printf<span class="op">(</span><span class="st">&quot;%d, %d&quot;</span><span class="op">,</span> pt<span class="op">.</span>x<span class="op">,</span> pt<span class="op">.</span>y<span class="op">);</span></span></code></pre></div>
<p>Structures can be nested.</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> rect <span class="op">{</span></span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> point pt1<span class="op">;</span></span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> point pt2<span class="op">;</span></span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> rect screen<span class="op">;</span></span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>    screen<span class="op">.</span>pt1<span class="op">.</span>x<span class="op">;</span>   <span class="co">/* refers to the x coordinate of the pt1 member of screen */</span></span></code></pre></div>
<h5 id="structures-and-functions">Structures and Functions</h5>
<blockquote>
<p>“The only legal operations on a structure are copying it (as a
unit/member by member), taking its address with &amp;, and accessing its
members.”</p>
</blockquote>
<blockquote>
<p>“The <code>.</code> operator is used to access members of a
structure, by adding the specific offset on the base address.”</p>
</blockquote>
<blockquote>
<p>“A structure name (‘s’) represents the entire block of memory for the
structure” “You cannot use (‘s’) as a pointer to the first member unlike
array. Instead, you use the address-of operator (‘&amp;’) to get a
pointer to the structure.”</p>
</blockquote>
<blockquote>
<p>“Pointers to structures are so frequently used that an alternative
notation is provided as a shorthand. If p is a pointer to a structure,
then <code>p-&gt;member-of-structure</code></p>
</blockquote>
<div class="sourceCode" id="cb39"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> rect r<span class="op">,</span> <span class="op">*</span>rp <span class="op">=</span> <span class="op">&amp;</span>r<span class="op">;</span></span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* then these four expressions are equivalent: */</span></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>    r<span class="op">.</span>pt1<span class="op">.</span>x</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true" tabindex="-1"></a>    rp<span class="op">-&gt;</span>pt1<span class="op">.</span>x</span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>r<span class="op">.</span>pt1<span class="op">).</span>x</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true" tabindex="-1"></a>    <span class="op">(</span>rp<span class="op">-&gt;</span>pt1<span class="op">).</span>x</span></code></pre></div>
<h4 id="arrays-of-structures">Arrays of Structures</h4>
<div class="sourceCode" id="cb40"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> key <span class="op">{</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> <span class="op">*</span>word<span class="op">;</span></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count<span class="op">;</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> keytab<span class="op">[</span>NKEYS<span class="op">];</span></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* this could also be written */</span></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> key <span class="op">{</span></span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> <span class="op">*</span>word<span class="op">;</span></span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count<span class="op">;</span></span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> key keytab<span class="op">[</span>NKEYS<span class="op">];</span></span></code></pre></div>
<p>Since the structure <code>keytab</code> contains a constant set of
names, it is easiest to make it an external variable and initialize it
once for all when it is defined. The structure initialization is
analogous to earlier ones - the definition is followed by a list of
initializers enclosed in braces:</p>
<div class="sourceCode" id="cb41"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> key <span class="op">{</span></span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> <span class="op">*</span>word<span class="op">;</span></span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count<span class="op">;</span></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> keytab<span class="op">[]</span> <span class="op">=</span> <span class="op">{</span></span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;auto&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;break&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;case&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;char&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;const&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb41-10"><a href="#cb41-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;continue&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb41-11"><a href="#cb41-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;default&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb41-12"><a href="#cb41-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;unsigned&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb41-13"><a href="#cb41-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;void&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb41-14"><a href="#cb41-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;volatile&quot;</span><span class="op">,</span> <span class="dv">0</span><span class="op">,</span></span>
<span id="cb41-15"><a href="#cb41-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;while&quot;</span><span class="op">,</span> <span class="dv">0</span></span>
<span id="cb41-16"><a href="#cb41-16" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span>
<span id="cb41-17"><a href="#cb41-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* as usual, the number of entries in the array will be computed</span></span>
<span id="cb41-18"><a href="#cb41-18" aria-hidden="true" tabindex="-1"></a><span class="co">     * if the initializers are present and the [ ] is left empty. */</span></span></code></pre></div>
<h4 id="self-referential-structures">Self-referential Structures</h4>
<p>The binary tree data structure use a self-reference.</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> tnode <span class="op">{</span>              <span class="co">/* the tree node:           */</span></span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> <span class="op">*</span>word<span class="op">;</span>             <span class="co">/* points to the text       */</span></span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">int</span> count<span class="op">;</span>              <span class="co">/* number of occurrences    */</span></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> tnode <span class="op">*</span>left<span class="op">;</span>     <span class="co">/* left child               */</span></span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> tnode <span class="op">*</span>right<span class="op">;</span>    <span class="co">/* right child              */</span></span></code></pre></div>
<h4 id="table-lookup">Table Lookup</h4>
<p>When a line like <code>#define IN 1</code> is encountered, the name
IN and the replacement text 1 are stored in a table. Later, when IN
appears in a statement like <code>state = IN;</code> it must be replaced
by 1.</p>
<p>There are two routines that manipulate the names and replacement
texts.</p>
<ul>
<li><code>install(s,t)</code> records the name s and the replacement
text in a table</li>
<li><code>lookup(s)</code> search for s in the table</li>
</ul>
<p>A block in the list is a structure containing pointers to the name,
the replacement text, and the next block in the list.</p>
<div class="sourceCode" id="cb43"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> list <span class="op">{</span>               <span class="co">/* table entry:         */</span></span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>        <span class="kw">struct</span> nlist <span class="op">*</span>next<span class="op">;</span>     <span class="co">/* next entry in chain  */</span></span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> <span class="op">*</span>name<span class="op">;</span>             <span class="co">/* defined name         */</span></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">char</span> <span class="op">*</span>defn<span class="op">;</span>             <span class="co">/* stand for definiton: replacement text */</span></span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<h4 id="typedef">Typedef</h4>
<p>C provides a facility called <code>typedef</code> for creating new
data type names.</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* for example, the declaration */</span></span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">typedef</span> <span class="dt">int</span> Length<span class="op">;</span></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* makes the name Length a synonym for int */</span></span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* the type Length can be used in declarations,</span></span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a><span class="co">    * casts, etc, in exaclty the same ways that the int type can be */</span></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>    Length len<span class="op">,</span> maxlen<span class="op">;</span></span>
<span id="cb44-7"><a href="#cb44-7" aria-hidden="true" tabindex="-1"></a>    Length <span class="op">*</span>lengths<span class="op">[</span>s<span class="op">];</span></span></code></pre></div>
<p>Notice that the type being declared in a <code>typedef</code> appears
in the position of a variable name, not right after the word
<code>typedef</code>. Syntactically, <code>typedef</code>is like the
storage classes <code>extern</code>, <code>static</code>, etc. We have
used capitalized names for <code>typedef</code>s, to make them stand
out.</p>
<blockquote>
<p>“It must be emphasized that a <code>typedef</code> declaration does
not create a new type in any sense; it merely adds a new name for some
existing type.”</p>
</blockquote>
<p>Besides purely aesthetic issues, there are two main reasons for using
<code>typedef</code>s:</p>
<ul>
<li><p>The first is to parameterize a program against portability
problems.</p></li>
<li><p>The second is to provide better documentation for a
program.</p></li>
</ul>
<h4 id="unions">Unions</h4>
<p>A <strong>union</strong> is a variable that may hold (at different
times) objects of different types and sizes, with the compiler keeping
track of size and alignment requirements. Unions provide a way to
manipulate different kinds of data in a single area of storage.</p>
<blockquote>
<p>“In effect, a union is a structure in which all members have offset
zero from the base, the structure is big enough to hold the”widest”
member, and the alignment is appropriate for all of the types in the
union.”</p>
</blockquote>
<blockquote>
<p>“A union may only be initialized with a value of the type of its
first member.”</p>
</blockquote>
<blockquote>
<p>“Unions, like structures, are derived datatypes which group together
a number of variables. However, the way the two treat these variables is
totally different. While the elements of a structure enable us to access
different locations in memory, the elements of a union serve as
different names by which the same portion of memory can be
accessed.”</p>
</blockquote>
<h4 id="bit-fields">Bit-fields</h4>
<blockquote>
<p>“Using bit fields in C is analogous to creating a custom-tailored
word”</p>
</blockquote>
<blockquote>
<p>“The <code>:</code> operator is known as the bit field width
specifier, it’s used to specify the number of bits that a particular
field within a structure will occupy”</p>
</blockquote>
<div class="sourceCode" id="cb45"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>    <span class="kw">struct</span> <span class="op">{</span></span>
<span id="cb45-2"><a href="#cb45-2" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> field1 <span class="op">:</span> <span class="dv">3</span><span class="op">;</span></span>
<span id="cb45-3"><a href="#cb45-3" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> field2 <span class="op">:</span> <span class="dv">5</span><span class="op">;</span></span>
<span id="cb45-4"><a href="#cb45-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">unsigned</span> <span class="dt">int</span> field3 <span class="op">:</span> <span class="dv">6</span><span class="op">;</span></span>
<span id="cb45-5"><a href="#cb45-5" aria-hidden="true" tabindex="-1"></a>    <span class="op">};</span></span></code></pre></div>
<ul>
<li><code>field1</code> will use 3 bits, <code>field2</code> will use 5
bits etc…</li>
</ul>
<blockquote>
<p>“When you use the <code>:</code> operator to define bit fields in a
struct, the compiler packs these field tightly together”</p>
</blockquote>
<h3 id="chapter-7---input-and-output">Chapter 7 - Input and Output</h3>
<blockquote>
<p>“We will not present the entire library here, since we are more
interested in writing C programs that use it.”</p>
</blockquote>
<blockquote>
<p>“The library implements a simple model of text input and output. A
text stream consists of a sequence of lines; each line ends with a
newline character. If the system doesn’t operate that way, the library
does whatever necessary to make it appear as if it does.”</p>
</blockquote>
<h5 id="variable-length-argument-lists">Variable-length Argument
Lists</h5>
<p>This section contains an implementation of a minimal version of
<code>printf</code>, to show how to write a function that processes a
variable-length argument list in a portable way.</p>
<div class="sourceCode" id="cb46"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* the proper declaration for printf is */</span></span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> printf<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>fmt<span class="op">,</span> <span class="op">...);</span></span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* where the declaration ... means that the number and types of these</span></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a><span class="co">     * arguments may vary */</span></span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* minprintf is declared as */</span></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">void</span> minprintf<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>fmt<span class="op">,</span> <span class="op">...);</span></span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* since we will not return the character count that printf does. */</span></span></code></pre></div>
<p>The tricky bit is how <code>minprintf</code> walks along the
argumnent list when the list doesn’t even have a name. The standard
header <code>&lt;stdarg.h&gt;</code> contains a set of macro definitions
that define how to step through an argument list. The implementation of
this header will vary from machine to machine, but the interface it
presents is uniform.</p>
<p>The type <code>va_list</code> is used to declare a variable that will
refer to each argument in turn; in <code>minprintf</code>, this variable
is call <code>ap</code> for “argument pointer”. The macro
<code>va_start</code> initializes <code>ap</code> to point to the first
unnamed argument. It must be called once before <code>ap</code> is used.
There must be at least one named argument; the final named argument is
used by <code>va_start</code> to get started.</p>
<p>See: minprintf.c</p>
<h4 id="formatted-input---scanf">Formatted Input - Scanf</h4>
<blockquote>
<p>“<code>scanf</code> stops when it exhausts its format string, or when
some input fails to match the control specification. It returns as its
value the number of succesfully matched and assigned input items. This
can be used to decide how many items were found.”</p>
</blockquote>
<blockquote>
<p>“There is also a function <code>sscanf</code> that reads from a
string instead of the standard input”</p>
</blockquote>
<div class="sourceCode" id="cb47"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> sscanf<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>string<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>format<span class="op">,</span> arg1<span class="op">,</span> arg2<span class="op">,</span> <span class="op">...);</span></span></code></pre></div>
<p>It scans the <code>string</code> according to the format in
<code>format</code> and stores the resulting values through
<code>arg1</code>, <code>arg2</code>, etc. These arguments must be
pointers.</p>
<p>The format string usually contains conversion specifications, which
are used to control conversion of input. The format string may
contain:</p>
<ul>
<li>Blanks or tabs, which are not ignored.</li>
<li>Ordinary characters (not %), which are expected to match the next
non-white space character of the input stream</li>
<li>Conversion specifications, consisting of the characters %, an
optional assignment suppression character *, an optional number
specifying a maximum field width, an optional h, l or L indicating the
width of the target, and a conversion character.</li>
</ul>
<div class="sourceCode" id="cb48"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a><span class="dt">int</span> main<span class="op">()</span> <span class="op">{</span></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">const</span> <span class="dt">char</span> <span class="op">*</span>input <span class="op">=</span> <span class="st">&quot;123456 789 1234.56 7890&quot;</span><span class="op">;</span></span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> first<span class="op">;</span></span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">double</span> third<span class="op">;</span></span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> <span class="dt">int</span> fourth<span class="op">;</span></span>
<span id="cb48-8"><a href="#cb48-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb48-9"><a href="#cb48-9" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Using sscanf to read the integers and floating-point numbers with specified width and length</span></span>
<span id="cb48-10"><a href="#cb48-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">// Suppress assignment of the second number</span></span>
<span id="cb48-11"><a href="#cb48-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="op">(</span>sscanf<span class="op">(</span>input<span class="op">,</span> <span class="st">&quot;%5d %*4hd %lf %ld&quot;</span><span class="op">,</span> <span class="op">&amp;</span>first<span class="op">,</span> <span class="op">&amp;</span>third<span class="op">,</span> <span class="op">&amp;</span>fourth<span class="op">)</span> <span class="op">==</span> <span class="dv">3</span><span class="op">)</span> <span class="op">{</span></span>
<span id="cb48-12"><a href="#cb48-12" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;First number (max width 5): %d</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> first<span class="op">);</span></span>
<span id="cb48-13"><a href="#cb48-13" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Third number (double): %lf</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> third<span class="op">);</span></span>
<span id="cb48-14"><a href="#cb48-14" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Fourth number (long int): %ld</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">,</span> fourth<span class="op">);</span></span>
<span id="cb48-15"><a href="#cb48-15" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></span>
<span id="cb48-16"><a href="#cb48-16" aria-hidden="true" tabindex="-1"></a>        printf<span class="op">(</span><span class="st">&quot;Error reading input string.</span><span class="sc">\n</span><span class="st">&quot;</span><span class="op">);</span></span>
<span id="cb48-17"><a href="#cb48-17" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span>
<span id="cb48-18"><a href="#cb48-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-19"><a href="#cb48-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="dv">0</span><span class="op">;</span></span>
<span id="cb48-20"><a href="#cb48-20" aria-hidden="true" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<h4 id="file-access">File Access</h4>
<blockquote>
<p>“The examples so far have all read the standard input and written the
standard ouput, which are automatically defined for a program by the
local operating system.”</p>
</blockquote>
<blockquote>
<p>“The next step is to write a program that accesses a file that is not
already connected to the program.”</p>
</blockquote>
<div class="sourceCode" id="cb49"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">;</span></span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">FILE</span> <span class="op">*</span>fopen<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>name<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>mode<span class="op">);</span></span></code></pre></div>
<p>This say that <code>fp</code>is a pointer to a <code>FILE</code>, and
<code>fopen</code> returns a pointer to a <code>FILE</code>. Notice that
<code>FILE</code> is a type name, like <code>int</code>, not a structure
tag; it is defined with a <code>typedef</code></p>
<div class="sourceCode" id="cb50"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* the call of fopen in a program is: */</span></span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>    fp <span class="op">=</span> fopen<span class="op">(</span>name<span class="op">,</span> mode<span class="op">);</span></span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* getc returns the next character from the stream referred by fp</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a><span class="co">     * it returns EOF for end of the file or error */</span></span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> getc<span class="op">(</span><span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">);</span></span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* putc writes the character c to the file fp and returns the </span></span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a><span class="co">     * character written, or EOF if an error occurs. */</span></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> putc<span class="op">(</span><span class="dt">int</span> c<span class="op">,</span> <span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">)</span></span></code></pre></div>
<p>When a C program is started, the operating system environment is
responsible for opening three files and providing pointers for them.
These files are the standard input, the standard ouput, and the standard
error; the corresponding file pointers are called <code>stdin</code>,
<code>stdout</code>, and <code>stderr</code>, and are declared in
<code>&lt;stdio.h&gt;</code>. Normally <code>stdin</code> is connected
to the keyboard and <code>stdout</code> and <code>stdout</code> are
connected to the screen, but <code>stdin</code> and <code>stdout</code>
may be redirected to files or pipes…</p>
<p><code>getchar</code> and <code>putchar</code> can be defined in terms
of <code>getc</code>, <code>putc</code>, <code>stdin</code> and
<code>stdput</code> as follows:</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define getchar()   getc(stdin)</span></span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#define putchar()   putc((c, stdout)</span></span></code></pre></div>
<p>For formatted input or output of files, the functions
<code>fscanf</code> and <code>fprintf</code> may be used. These are
identical to <code>scanf</code> and <code>printf</code>, except that the
first argument is a file pointer that specifies the file to be read or
written; the format string is the second argument.</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fscanf<span class="op">(</span><span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>format<span class="op">,</span> <span class="op">...)</span></span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> fprintf<span class="op">(</span><span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>format<span class="op">,</span> <span class="op">...)</span></span></code></pre></div>
<h4 id="error-handling---stderr-and-exit">Error Handling - Stderr and
Exit</h4>
<blockquote>
<p>“<code>stderr</code>is not a traditional file; it is a stream.”</p>
</blockquote>
<blockquote>
<p>“<code>exit</code> terminates program execution when it is called.
The argument of <code>exit</code> is available to whatever process
called this one, so the success or failure of the program can be tested
by another program that uses this one as a sub-process. Conventionally,
a return value of 0 signals that all is well; non-zero values usually
signal abnormal situtations. <code>exit</code> calls <code>fclose</code>
for each open output file, to flush out any buffered output.</p>
</blockquote>
<blockquote>
<p>“within <code>main</code>, <code>return</code> expr is equivalent to
<code>exit(expr)</code>.”</p>
</blockquote>
<p>We have generally not worried about exit status in our small
illustrative programs, but any serious program should take care to
return sensible, useful status values.</p>
<h4 id="line-input-and-output">Line Input and Output</h4>
<p>The standard library provides an input and output routine
<code>fgets</code> that is similar to the <code>getline</code> function
that we have used in earlier chapter.</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">char</span> <span class="op">*</span>gets<span class="op">(</span><span class="dt">char</span> <span class="op">*</span>line<span class="op">,</span> <span class="dt">int</span> maxline<span class="op">,</span> <span class="dt">FILE</span> <span class="op">*</span>fp<span class="op">)</span></span></code></pre></div>
<p><code>fgets</code> reads the next input line (including the newline)
from file <code>fp</code> into the character array <code>line</code>; at
most <code>maxline-1</code> characters will be read.</p>
<p>Normally <code>fgets</code> return <code>line</code>; on end of file
or error it return <code>NULL</code>.</p>
<h4 id="miscellaneous-functions">Miscellaneous functions</h4>
<p>The standard library most useful functions:</p>
<ul>
<li><code>s</code>, <code>t</code> are <code>char*</code></li>
<li><code>c</code>, <code>n</code> are <code>int</code></li>
</ul>
<h5 id="string.h-functions-summary"><code>&lt;string.h&gt;</code>
Functions Summary</h5>
<table>
<colgroup>
<col style="width: 19%" />
<col style="width: 80%" />
</colgroup>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>strcat(s, t)</code></td>
<td>Concatenate <code>t</code> to the end of <code>s</code></td>
</tr>
<tr class="even">
<td><code>strncat(s, t, n)</code></td>
<td>Concatenate <code>n</code> characters of <code>t</code> to the end
of <code>s</code></td>
</tr>
<tr class="odd">
<td><code>strcmp(s, t)</code></td>
<td>Return negative, zero, or positive for <code>s &lt; t</code>,
<code>s == t</code>, <code>s &gt; t</code></td>
</tr>
<tr class="even">
<td><code>strncmp(s, t, n)</code></td>
<td>Same as <code>strcmp</code> but only for the first <code>n</code>
characters</td>
</tr>
<tr class="odd">
<td><code>strcpy(s, t)</code></td>
<td>Copy <code>t</code> to <code>s</code></td>
</tr>
<tr class="even">
<td><code>strncpy(s, t, n)</code></td>
<td>Copy at most <code>n</code> characters of <code>t</code> to
<code>s</code></td>
</tr>
<tr class="odd">
<td><code>strlen(s)</code></td>
<td>Return length of <code>s</code></td>
</tr>
<tr class="even">
<td><code>strchr(s, c)</code></td>
<td>Return pointer to the first occurrence of <code>c</code> in
<code>s</code>, or <code>NULL</code> if not present</td>
</tr>
<tr class="odd">
<td><code>strrchr(s, c)</code></td>
<td>Return pointer to the last occurrence of <code>c</code> in
<code>s</code>, or <code>NULL</code> if not present</td>
</tr>
</tbody>
</table>
<h5 id="ctype.h-functions-summary"><code>&lt;ctype.h&gt;</code>
Functions Summary</h5>
<ul>
<li><code>c</code> is <code>int</code> that can be represented as an
unsigned char or <code>EOF</code></li>
<li>Function returns <code>int</code></li>
</ul>
<table>
<colgroup>
<col style="width: 12%" />
<col style="width: 87%" />
</colgroup>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>isalpha(c)</code></td>
<td>Non-zero if <code>c</code> is alphabetic, 0 if not</td>
</tr>
<tr class="even">
<td><code>isupper(c)</code></td>
<td>Non-zero if <code>c</code> is upper case, 0 if not</td>
</tr>
<tr class="odd">
<td><code>islower(c)</code></td>
<td>Non-zero if <code>c</code> is lower case, 0 if not</td>
</tr>
<tr class="even">
<td><code>isdigit(c)</code></td>
<td>Non-zero if <code>c</code> is a digit, 0 if not</td>
</tr>
<tr class="odd">
<td><code>isalnum(c)</code></td>
<td>Non-zero if <code>isalpha(c)</code> or <code>isdigit(c)</code>, 0 if
not</td>
</tr>
<tr class="even">
<td><code>isspace(c)</code></td>
<td>Non-zero if <code>c</code> is blank, tab, newline, return, formfeed,
or vertical tab</td>
</tr>
<tr class="odd">
<td><code>toupper(c)</code></td>
<td>Return <code>c</code> converted to upper case</td>
</tr>
<tr class="even">
<td><code>tolower(c)</code></td>
<td>Return <code>c</code> converted to lower case</td>
</tr>
</tbody>
</table>
<h6 id="math.h-functions-summary"><code>&lt;math.h&gt;</code> Functions
Summary</h6>
<ul>
<li>All functions take one or two <code>double</code> arguments and
return a <code>double</code>.</li>
</ul>
<table>
<colgroup>
<col style="width: 23%" />
<col style="width: 76%" />
</colgroup>
<thead>
<tr class="header">
<th>Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>sin(x)</code></td>
<td>Sine of <code>x</code>, where <code>x</code> is in radians</td>
</tr>
<tr class="even">
<td><code>cos(x)</code></td>
<td>Cosine of <code>x</code>, where <code>x</code> is in radians</td>
</tr>
<tr class="odd">
<td><code>atan2(y, x)</code></td>
<td>Arctangent of <code>y/x</code>, in radians</td>
</tr>
<tr class="even">
<td><code>exp(x)</code></td>
<td>Exponential function ( e^x )</td>
</tr>
<tr class="odd">
<td><code>log(x)</code></td>
<td>Natural (base e) logarithm of <code>x</code> (x &gt; 0)</td>
</tr>
<tr class="even">
<td><code>log10(x)</code></td>
<td>Common (base 10) logarithm of <code>x</code> (x &gt; 0)</td>
</tr>
<tr class="odd">
<td><code>pow(x, y)</code></td>
<td>( x^y )</td>
</tr>
<tr class="even">
<td><code>sqrt(x)</code></td>
<td>Square root of <code>x</code> (x &gt; 0)</td>
</tr>
<tr class="odd">
<td><code>fabs(x)</code></td>
<td>Absolute value of <code>x</code></td>
</tr>
</tbody>
</table>
<h4 id="the-unix-system-interface">The UNIX System Interface</h4>
<p>The UNIX operating system provides its services through a set of
system call, which are in effect functions within the operating system
that may be called by user programs.</p>
<p>In the UNIX operating system, all input and output is done by reading
or writing files, because all peripheral devices, even keyboard and
screen, are files in the file system. This means that a single
homogeneous interface handles all communication between a program and
peripheral devices.</p>
<p>Since input and output involking keyboard and screen is so commom,
special arragements exist to make this convenient. When the command
interpreter (the “shell”) runs a programs, three files are open, with
file descriptos 0, 1, and 2, called the standard input, the standard
output, and the standard error. If a program reads 0, and writes 1 and
2, it can do input and output without worrying about opening files.</p>
<p>The user of a program can redirect I/O to and from files with
<code>&lt;</code> and <code>&gt;</code>:
<code>prog &lt;infile &gt;outfile</code></p>
<p>In this case, the shell changes the default assignements for the file
descriptors 0 and 1 to the named files.</p>
<blockquote>
<p>“In all cases, the file assignements are changed by the shell, not by
the program”</p>
</blockquote>
<h5 id="low-level-io---read-and-write">Low level I/O - Read and
Write</h5>
<p>In the UNIX file system, there are nine bits of permission
information associated with a file that control read, write and execute
access for the owner of the file, for the owner’s group, and for all
others. Thus a three-digit octal number is convenient for specifying the
permissions.</p>
<p><strong>Mapping Permissions to Binary and Octal:</strong></p>
<ul>
<li>r (read) = 4 (100 in binary)</li>
<li>w (write) = 2 (010 in binary)</li>
<li>x (execute) = 1 (001 in binary)</li>
</ul>
<table>
<colgroup>
<col style="width: 7%" />
<col style="width: 29%" />
<col style="width: 62%" />
</colgroup>
<thead>
<tr class="header">
<th>System Call</th>
<th>Return Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>open</code></td>
<td>&gt;= 0</td>
<td>On success, returns a file descriptor (a non-negative integer).</td>
</tr>
<tr class="even">
<td></td>
<td>-1 and sets <code>errno</code></td>
<td>On failure, returns -1 and sets <code>errno</code> to indicate the
error.</td>
</tr>
<tr class="odd">
<td><code>read</code></td>
<td>&gt; 0</td>
<td>On success, returns the number of bytes read.</td>
</tr>
<tr class="even">
<td></td>
<td>0</td>
<td>On end-of-file, returns 0.</td>
</tr>
<tr class="odd">
<td></td>
<td>-1 and sets <code>errno</code></td>
<td>On failure, returns -1 and sets <code>errno</code> to indicate the
error.</td>
</tr>
<tr class="even">
<td><code>creat</code></td>
<td>&gt;= 0</td>
<td>On success, returns a file descriptor (a non-negative integer).</td>
</tr>
<tr class="odd">
<td></td>
<td>-1 and sets <code>errno</code></td>
<td>On failure, returns -1 and sets <code>errno</code> to indicate the
error.</td>
</tr>
<tr class="even">
<td><code>write</code></td>
<td>&gt;= 0</td>
<td>On success, returns the number of bytes written.</td>
</tr>
<tr class="odd">
<td></td>
<td>-1 and sets <code>errno</code></td>
<td>On failure, returns -1 and sets <code>errno</code> to indicate the
error.</td>
</tr>
</tbody>
</table>
<blockquote>
<p>“Termination of a program via <code>exit</code> or return from the
main program closes all open files”</p>
</blockquote>
<h4 id="random-access---lseek">Random Access - Lseek</h4>
<p>The system call <code>lseek</code> provides a way to move around in a
file without reading or writing any data;</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a>    <span class="dt">long</span> lseek<span class="op">(</span><span class="dt">int</span> fd<span class="op">,</span> <span class="dt">long</span> offset<span class="op">,</span> <span class="dt">int</span> origin<span class="op">);</span></span></code></pre></div>
<p>sets the current position in the file whose descriptor is
<code>fd</code> to <code>offset</code>, which is taken relative to the
location specified by <code>origin</code>.</p>
<p>For example, the following function reads any number of bytes from
any arbitrary place in a file. It returns the number read, or -1 on
error</p>
<div class="sourceCode" id="cb55"><pre class="sourceCode c"><code class="sourceCode c"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>    <span class="pp">#include </span><span class="im">&quot;syscalls.h&quot;</span></span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">/* get: read n bytes from position pos */</span></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>    <span class="dt">int</span> get<span class="op">(</span><span class="dt">int</span> fd<span class="op">,</span> <span class="dt">long</span> pos<span class="op">,</span> <span class="dt">char</span> <span class="op">*</span>buf<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="op">(</span>lseek<span class="op">(</span>fd<span class="op">,</span> pos<span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">&gt;=</span> <span class="dv">0</span><span class="op">)</span> <span class="co">/* get to pos */</span></span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> read<span class="op">(</span>fd<span class="op">,</span> buf<span class="op">,</span> n<span class="op">);</span></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span><span class="op">;</span></span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>    <span class="op">}</span></span></code></pre></div>
<p>The return value from <code>lseek</code> is a long that gives the new
position in the file, or -1 if an error occurs.</p>
<h4 id="listing-directories">Listing Directories</h4>
<blockquote>
<p>“Let us begin with a short review of UNIX file system structure. A
directory is a file that contains a list of filenames and some
indication of where they are located. The ‘location’ is an index into
another table called the ‘inode list’. The <em>inode</em> for a file is
where all information about the file except its name is kept. A
directory entry generally consists of only two items, the filename and
an inode number.”</p>
</blockquote>
</body>
</html>


  </body>
</html>
